#!/usr/bin/env bash

# -e: exit immediately if a command exits with a non-zero status.
# -u: treat unset variables as an error.
# -o pipefail: cause a pipeline to fail if any command fails.
set -euo pipefail

# --- Functions ---

usage_and_exit() {
    echo "Usage: $(basename "$0") [-f fps] [-w width] [-h height] [-c codec] [-v] infile outfile" >&2
    echo "  Defaults: fps=1 width=320 height=240 codec=vp9" >&2
    echo "  Supported codecs: vp9, h264, h265, ffv1, ffv1l3" >&2
    exit "$1"
}

check_dependencies() {
    if ! command -v ffmpeg &> /dev/null; then
        echo "error: required command 'ffmpeg' not found." >&2
        exit 2
    fi
    if ! command -v xxd &> /dev/null; then
        echo "error: required command 'xxd' not found." >&2
        exit 2
    fi
}

# --- Main logic ---

# Check for help flag early
if [[ "${1:-}" = '--help' ]]; then
    usage_and_exit 0
fi

# Check for required binaries
check_dependencies

# --- Argument parsing ---
width=320
height=240
framerate=1
codec="vp9"
verbose=0

while getopts 'f:w:h:c:v' option; do
    case "$option" in
        f) framerate="$OPTARG";;
        w) width="$OPTARG";;
        h) height="$OPTARG";;
        c) codec="$OPTARG";;
        v) verbose=1;;
        ?) usage_and_exit 1;;
    esac
done
shift $((OPTIND - 1))

# Define codec-specific options in an associative array
declare -A codec_options=(
    ["vp9"]="-c:v libvpx-vp9 -lossless 1"
    ["h264"]="-c:v libx264rgb -preset ultrafast -qp 0"
    ["h265"]="-c:v libx265 -x265-params lossless=1"
    ["ffv1"]="-c:v ffv1 -level 1 -coder 1 -context 1 -g 1"
    ["ffv1l3"]="-c:v ffv1 -level 3 -threads 8 -coder 1 -context 1 -g 1 -slices 24 -slicecrc 1"
)

# Verify codec and retrieve options
if [[ -z "${codec_options[$codec]:-}" ]]; then
    echo "error: unknown codec '$codec'" >&2
    usage_and_exit 3
fi
ffmpeg_codec_opts="${codec_options[$codec]}"

# --- Input/Output validation ---
if [[ $# -ne 2 ]]; then
    usage_and_exit 1
fi

infile="$1"
outfile="$2"

if [[ ! -r "$infile" ]]; then
    echo "error: file '$infile' does not exist or is not readable" >&2
    exit 4
fi

# --- Main process ---
pixel_format=rgb24
header_size=8
blocksize=$((width * height * 3))
size_infile=$(stat -c %s "${infile}")

if [[ $verbose -eq 1 ]]; then
    echo "parameters: fps=$framerate width=$width height=$height codec=$codec"
    echo "blocksize is $blocksize bytes"
    echo "input file has $size_infile bytes"
    echo "input file MD5: $(md5sum "$infile" | awk '{print $1}')"
fi

# --- Header creation and padding using a temporary file ---
tmpdir=$(mktemp -d --tmpdir binary2video.XXXXXXXXXX)
trap 'rm -rf "$tmpdir"' EXIT
tmpfile_padded="$tmpdir/infile.padded"

# A reliable way to create an 8-byte header from the file size
# This avoids issues with shell commands handling binary data and null bytes.
{ printf '%016x' "$size_infile"; } | xxd -r -p > "${tmpfile_padded}"
cat "${infile}" >> "${tmpfile_padded}"

# Calculate and apply padding
size_with_header=$(stat -c %s "${tmpfile_padded}")
padding_needed=$((blocksize - (size_with_header % blocksize)))
if [[ padding_needed -eq blocksize ]]; then
    padding_needed=0
fi

if [[ $verbose -eq 1 ]]; then
    echo "header has $header_size bytes"
    echo "padding needed: $padding_needed bytes"
fi

# Append padding bytes
printf '\0%.0s' $(seq 1 "$padding_needed") >> "${tmpfile_padded}"

if [[ $verbose -eq 1 ]]; then
    echo "padded file has $(stat -c %s "${tmpfile_padded}") bytes"
fi

# Run ffmpeg command using the temporary padded file as input
ffmpeg_log_level="error"
if [[ $verbose -eq 1 ]]; then
    ffmpeg_log_level="info"
fi

ffmpeg -y -hide_banner -loglevel "$ffmpeg_log_level" \
    -f rawvideo -pixel_format "$pixel_format" -video_size "${width}x${height}" -framerate "$framerate" -i "${tmpfile_padded}" \
    $ffmpeg_codec_opts \
    "${outfile}"

# --- Post-process ---
if [[ $verbose -eq 1 ]]; then
    if [[ -f "$outfile" ]]; then
        echo "output file has $(stat -c %s "${outfile}") bytes"
        echo -n "output file MD5: "
        md5sum "${outfile}" | awk '{print $1}'
    else
        echo "error: output file was not created" >&2
        exit 5
    fi
fi

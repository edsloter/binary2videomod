#!/usr/bin/env bash

# -e: exit immediately if a command exits with a non-zero status.
# -u: treat unset variables as an error.
# -o pipefail: cause a pipeline to fail if any command fails.
set -euo pipefail

# --- Functions ---

usage_and_exit() {
    echo "Usage: $(basename "$0") [-f fps] [-w width] [-h height] [-c codec] [-p par2_redundancy] [-v] infile outfile" >&2
    echo "  Defaults: fps=1 width=320 height=240 codec=vp9" >&2
    echo "  Supported codecs: vp9, h264, h265, ffv1, ffv1l3" >&2
    echo "  -p: Create par2 recovery files with specified redundancy percentage (e.g., '-p 10'). Requires 'par2'. Off by default." >&2
    exit "$1"
}

check_dependencies() {
    if ! command -v ffmpeg &> /dev/null; then
        echo "error: required command 'ffmpeg' not found." >&2
        exit 2
    fi
    if ! command -v xxd &> /dev/null; then
        echo "error: required command 'xxd' not found." >&2
        exit 2
    fi
}

# --- Main logic ---

# Check for help flag early
if [[ "${1:-}" = '--help' ]]; then
    usage_and_exit 0
fi

# Check for required binaries
check_dependencies

# --- Argument parsing ---
width=320
height=240
framerate=1
codec="vp9"
verbose=0
par2_redundancy=""

while getopts 'f:w:h:c:p:v' option; do
    case "$option" in
        f) framerate="$OPTARG";;
        w) width="$OPTARG";;
        h) height="$OPTARG";;
        c) codec="$OPTARG";;
        p)
            if ! command -v par2 &> /dev/null; then
                echo "error: 'par2' is not installed but the -p flag was used." >&2
                exit 6
            fi
            if ! [[ "$OPTARG" =~ ^[0-9]+$ ]] || [[ "$OPTARG" -lt 1 || "$OPTARG" -gt 100 ]]; then
                echo "error: -p value must be a number between 1 and 100." >&2
                exit 7
            fi
            par2_redundancy="$OPTARG"
            ;;
        v) verbose=1;;
        ?) usage_and_exit 1;;
    esac
done
shift $((OPTIND - 1))

# Define codec-specific options in an associative array
declare -A codec_options=(
    ["vp9"]="-c:v libvpx-vp9 -lossless 1"
    ["h264"]="-c:v libx264rgb -preset ultrafast -qp 0"
    ["h265"]="-c:v libx265 -x265-params lossless=1"
    ["ffv1"]="-c:v ffv1 -level 1 -coder 1 -context 1 -g 1"
    ["ffv1l3"]="-c:v ffv1 -level 3 -threads 8 -coder 1 -context 1 -g 1 -slices 24 -slicecrc 1"
)

# Verify codec and retrieve options
if [[ -z "${codec_options[$codec]:-}" ]]; then
    echo "error: unknown codec '$codec'" >&2
    usage_and_exit 3
fi
ffmpeg_codec_opts="${codec_options[$codec]}"

# --- Input/Output validation ---
if [[ $# -ne 2 ]]; then
    usage_and_exit 1
fi

infile="$1"
outfile="$2"

if [[ ! -r "$infile" ]]; then
    echo "error: file '$infile' does not exist or is not readable" >&2
    exit 4
fi

# --- Main process ---
pixel_format=rgb24
header_size=8
blocksize=$((width * height * 3))

tmpdir=$(mktemp -d --tmpdir binary2video.XXXXXXXXXX)
trap 'rm -rf "$tmpdir"' EXIT

source_for_video=""

# Handle par2 creation if flag is set
if [[ -n "$par2_redundancy" ]]; then
    if [[ $verbose -eq 1 ]]; then
        echo "Creating par2 recovery files with ${par2_redundancy}% redundancy."
    fi

    # The -b flag ensures 'basename' handles paths with leading dashes correctly.
    infilename_basename=$(basename -- "$infile")
    
    # Copy the file and ensure par2 can access it with a relative path
    cp "$infile" "$tmpdir/$infilename_basename"

    # Change into the temporary directory to avoid "out of basepath" errors
    pushd "$tmpdir" >/dev/null

    # Run par2 with the relative filename and check for success
    if ! par2 create -r"${par2_redundancy}" "$infilename_basename" >/dev/null; then
        echo "error: par2 failed to create recovery files." >&2
        popd >/dev/null # Go back to original directory
        exit 8
    fi

    if [[ $verbose -eq 1 ]]; then
        echo "Combining par2 files with source file."
    fi

    # Combine par2 files and original file in the correct, numerically-sorted order.
    # We use 'find' with a null separator and 'sort' to handle file names properly.
    mapfile -d '' combined_files < <(find . -maxdepth 1 -type f -print0 | sort -zV)
    
    # Use process substitution to avoid creating another temporary file.
    source_for_video=$(mktemp)
    trap 'rm -rf "$tmpdir" "$source_for_video"' EXIT
    
    cat "${combined_files[@]}" > "$source_for_video"

    # Return to the original directory
    popd >/dev/null

else
    source_for_video="$infile"
fi

size_source=$(stat -c %s "$source_for_video")

if [[ $verbose -eq 1 ]]; then
    echo "parameters: fps=$framerate width=$width height=$height codec=$codec"
    echo "blocksize is $blocksize bytes"
    echo "source file has $size_source bytes"
    echo "source file MD5: $(md5sum "$source_for_video" | awk '{print $1}')"
fi

# --- Pipe header, data, and padding to ffmpeg ---

# Calculate and apply padding using a robust calculation
padding_needed=$(((blocksize - (size_source + header_size) % blocksize) % blocksize))

if [[ $verbose -eq 1 ]]; then
    echo "header has $header_size bytes"
    echo "padding needed: $padding_needed bytes"
fi

# Pipe everything directly into ffmpeg to avoid large temporary files
ffmpeg_log_level="error"
if [[ $verbose -eq 1 ]]; then
    ffmpeg_log_level="info"
fi

{
    printf '%016x' "$size_source" | xxd -r -p
    cat "$source_for_video"
    if [[ "$padding_needed" -gt 0 ]]; then
        printf '\0%.0s' $(seq 1 "$padding_needed")
    fi
} | ffmpeg -y -hide_banner -loglevel "$ffmpeg_log_level" \
    -f rawvideo -pixel_format "$pixel_format" -video_size "${width}x${height}" -framerate "$framerate" -i - \
    $ffmpeg_codec_opts \
    "${outfile}"

# Check ffmpeg exit status
if [[ $? -ne 0 ]]; then
    echo "error: ffmpeg failed to encode the video." >&2
    exit 5
fi

# --- Post-process ---
if [[ $verbose -eq 1 ]]; then
    if [[ -f "$outfile" ]]; then
        echo "output file has $(stat -c %s "${outfile}") bytes"
        echo -n "output file MD5: "
        md5sum "${outfile}" | awk '{print $1}'
    else
        echo "error: output file was not created" >&2
        exit 5
    fi
fi

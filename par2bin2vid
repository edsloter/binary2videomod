#!/usr/bin/env bash

# -e: exit immediately if a command exits with a non-zero status.
# -u: treat unset variables as an error.
# -o pipefail: cause a pipeline to fail if any command fails.
set -euo pipefail

# --- Functions ---

usage_and_exit() {
    echo "Usage: $(basename "$0") [-f fps] [-w width] [-h height] [-c codec] [-p par2_redundancy] [-v] infile outfile" >&2
    echo "  Defaults: fps=1 width=320 height=240 codec=vp9" >&2
    echo "  Supported codecs: vp9, h264, h265, ffv1, ffv1l3" >&2
    echo "  -p: Create par2 recovery files with specified redundancy percentage (e.g., '-p 10'). Requires 'par2'. Off by default." >&2
    exit "$1"
}

check_dependencies() {
    if ! command -v ffmpeg &> /dev/null; then
        echo "error: required command 'ffmpeg' not found." >&2
        exit 2
    fi
    if ! command -v xxd &> /dev/null; then
        echo "error: required command 'xxd' not found." >&2
        exit 2
    fi
}

# --- Main logic ---

# Check for help flag early
if [[ "${1:-}" = '--help' ]]; then
    usage_and_exit 0
fi

# Check for required binaries
check_dependencies

# --- Argument parsing ---
width=320
height=240
framerate=1
codec="vp9"
verbose=0
par2_redundancy=""

while getopts 'f:w:h:c:p:v' option; do
    case "$option" in
        f) framerate="$OPTARG";;
        w) width="$OPTARG";;
        h) height="$OPTARG";;
        c) codec="$OPTARG";;
        p)
            if ! command -v par2 &> /dev/null; then
                echo "error: par2 is not installed but the -p flag was used." >&2
                exit 6
            fi
            if ! [[ "$OPTARG" =~ ^[0-9]+$ ]] || [[ "$OPTARG" -lt 1 || "$OPTARG" -gt 100 ]]; then
                echo "error: -p value must be a number between 1 and 100." >&2
                exit 7
            fi
            par2_redundancy="$OPTARG"
            ;;
        v) verbose=1;;
        ?) usage_and_exit 1;;
    esac
done
shift $((OPTIND - 1))

# Define codec-specific options in an associative array
declare -A codec_options=(
    ["vp9"]="-c:v libvpx-vp9 -lossless 1"
    ["h264"]="-c:v libx264rgb -preset ultrafast -qp 0"
    ["h265"]="-c:v libx265 -x265-params lossless=1"
    ["ffv1"]="-c:v ffv1 -level 1 -coder 1 -context 1 -g 1"
    ["ffv1l3"]="-c:v ffv1 -level 3 -threads 8 -coder 1 -context 1 -g 1 -slices 24 -slicecrc 1"
)

# Verify codec and retrieve options
if [[ -z "${codec_options[$codec]:-}" ]]; then
    echo "error: unknown codec '$codec'" >&2
    usage_and_exit 3
fi
ffmpeg_codec_opts="${codec_options[$codec]}"

# --- Input/Output validation ---
if [[ $# -ne 2 ]]; then
    usage_and_exit 1
fi

infile="$1"
outfile="$2"

if [[ ! -r "$infile" ]]; then
    echo "error: file '$infile' does not exist or is not readable" >&2
    exit 4
fi

# --- Main process ---
pixel_format=rgb24
header_size=8
blocksize=$((width * height * 3))

tmpdir=$(mktemp -d --tmpdir binary2video.XXXXXXXXXX)
trap 'rm -rf "$tmpdir"' EXIT
tmpfile_padded="$tmpdir/infile.padded"
tmpfile_combined="$tmpdir/infile.combined"

# Handle par2 creation if flag is set
if [[ -n "$par2_redundancy" ]]; then
    if [[ $verbose -eq 1 ]]; then
        echo "Creating par2 recovery files with ${par2_redundancy}% redundancy."
    fi
    
    # Store the basename of the input file
    infilename_basename=$(basename -- "$infile")
    
    # Copy the input file into the temporary directory for par2 to process
    cp "$infile" "$tmpdir/$infilename_basename"
    
    # Change into the temporary directory to avoid "out of basepath" error
    pushd "$tmpdir" >/dev/null
    
    # Run par2 with the relative filename
    par2 create -r"$par2_redundancy" "$infilename_basename"
    
    # Return to the original directory
    popd >/dev/null
    
    if [[ $verbose -eq 1 ]]; then
        echo "Combining par2 files with source file."
    fi
    
    # Use glob to ensure par2 files (e.g., .par2, .vol*) are first, then the original file.
    # Note: `cd` is needed here to expand the glob correctly from the temporary directory.
    ( cd "$tmpdir" && cat *.par2 "$infilename_basename" ) > "$tmpfile_combined"
else
    # If no par2, the infile is the source for the video encoding
    cp "$infile" "${tmpfile_combined}"
fi

# Calculate sizes based on combined file if par2 was used, otherwise the original file.
size_source=$(stat -c %s "${tmpfile_combined}")

if [[ $verbose -eq 1 ]]; then
    echo "parameters: fps=$framerate width=$width height=$height codec=$codec"
    echo "blocksize is $blocksize bytes"
    echo "source file has $size_source bytes"
    echo "source file MD5: $(md5sum "${tmpfile_combined}" | awk '{print $1}')"
fi

# --- Header creation and padding using a temporary file ---
{ printf '%016x' "$size_source"; } | xxd -r -p > "${tmpfile_padded}"
cat "${tmpfile_combined}" >> "${tmpfile_padded}"

# Calculate and apply padding
size_with_header=$(stat -c %s "${tmpfile_padded}")
padding_needed=$((blocksize - (size_with_header % blocksize)))
if [[ padding_needed -eq blocksize ]]; then
    padding_needed=0
fi

if [[ $verbose -eq 1 ]]; then
    echo "header has $header_size bytes"
    echo "padding needed: $padding_needed bytes"
fi

# Append padding bytes
printf '\0%.0s' $(seq 1 "$padding_needed") >> "${tmpfile_padded}"

if [[ $verbose -eq 1 ]]; then
    echo "padded file has $(stat -c %s "${tmpfile_padded}") bytes"
fi

# Run ffmpeg command using the temporary padded file as input
ffmpeg_log_level="error"
if [[ $verbose -eq 1 ]]; then
    ffmpeg_log_level="info"
fi

ffmpeg -y -hide_banner -loglevel "$ffmpeg_log_level" \
    -f rawvideo -pixel_format "$pixel_format" -video_size "${width}x${height}" -framerate "$framerate" -i "${tmpfile_padded}" \
    $ffmpeg_codec_opts \
    "${outfile}"

# --- Post-process ---
if [[ $verbose -eq 1 ]]; then
    if [[ -f "$outfile" ]]; then
        echo "output file has $(stat -c %s "${outfile}") bytes"
        echo -n "output file MD5: "
        md5sum "${outfile}" | awk '{print $1}'
    else
        echo "error: output file was not created" >&2
        exit 5
    fi
fi
